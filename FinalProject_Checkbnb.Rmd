---
title: "The Future of Airbnb Hosting in Amsterdam: Checkbnb"
author: "Divya Khandke and Adam Ghazzawi"
date: "12/15/2020"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---
# The Motivation behind Checkbnb
Under newfound regulatory guidelines in Amsterdam, the Airbnb market is increasingly challenging to navigate. As of July 2020, the City of Amsterdam outright banned Airbnbs in three of Amsterdam's city center neighborhoods, limited to the number of nights that a host could rent out their property to 30 nights per year, restricted the number of guests that a property can host to 4, and enacted a permitting fee. Checkbnb, an affilate of Airbnb, allows prospective hosts to calculate the potential revenue of renting their property given the property's home specifications, listing details, and access to various amenities and features in the surrounding area.  The provided model leverages existing Amsterdam Airbnb data from 2018 to inform and construct a model that generalizes to Amsterdam's current rental market. The model output, potential revenue, gives users an accurate understanding of the possible financial gains that can result from renting out their home on the Airbnb platform. Given the challenging regulatory landscape, Checkbnb seeks to simplify the decision-making process for prospective hosts through an easy-to-use platform and accurate model. 
```{r setup, include=FALSE}
#######################
#LOADING SET UP PART 1
######################
knitr::opts_chunk$set(echo = TRUE)

root.dir = "https://github.com/amghazzawi/airbnb-predictions"

library(tidyverse)
library(tidycensus)
library(sf)
library(spdep)
library(caret)
library(ckanr)
library(FNN)
library(stargazer)
library(grid)
library(gridExtra)
library(ggcorrplot)
library(dplyr)
library(mapview)
library(jtools)
library(ggmap)
library(RColorBrewer)
library(wesanderson)
library(viridis)
library(broom)
library(rmarkdown)
library(knitr)
library(kableExtra)
library(osmdata)
library(pander)
```

```{r warning=FALSE, include=FALSE}
#######################
#LOADING SET UP PART 2
######################
mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 14,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2)
  )
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 14,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    plot.background = element_blank(),
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    strip.text.x = element_text(size = 14)
  )
}

palettemain <- c("#72b7cd","#cde1b1","#bdc2ab","#cab388","#c3904d","#ff5a5f")
paletteblues <- c( "#7fc3dc","#72b7cd","#2f8caa","#1a81a2","#037499")
paletteorngs <- c("#ceeece","#ebe3a3","#f6cb92","#f6c192","#f6b492") 
               

#Set up quintile breaks for map legends
qBr <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T))
  } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]]), digits = 3),
                 c(.01,.2,.4,.6,.8), na.rm=T)
  }
}

q5 <- function(variable) {as.factor(ntile(variable, 5))}

nn_function <- function(measureFrom,measureTo,k) {
  measureFrom_Matrix <- as.matrix(measureFrom)
  measureTo_Matrix <- as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
  output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}
```

# Model Data
The data used in our final Checkbnb model was sourced from Airbnb-provided data on 2018 listings in Amsterdam, open data provided by the City of Amsterdam, and Open Street Map (OSM) data that crowd-sources locations of various landmarks and amenities across the city. The Airbnb data consists of information on listing price, number of bedrooms and bathrooms, as well as other data on reviews and available amenities to home guests. The city's data includes information on locations of city-provided services, neighborhood features, sub-city boundaries, as well as information on land use types. Lastly, the OSM data provides other locational data on city amenities and features.
```{r, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results=FALSE}
#######################
# Data Loading Part 1 
######################
# Airbnb-provided data
listings_details <- read_csv("listings_details.csv")
listings_details$price2 = as.numeric(gsub("\\$", "", listings_details$price))

neighborhoods_new <- st_read("neighbourhoods.geojson")

neighborhoods_new.sf <- neighborhoods_new %>%
  st_as_sf(coords = "geometry", crs = 4326, agr = "constant") %>%
  st_transform('EPSG:28992')

districts <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=GEBIED_STADSDELEN&THEMA=gebiedsindeling") 

districts.sf <- districts %>%
  st_as_sf(coords = "geometry", crs = 4326, agr = "constant") %>%
  st_transform('EPSG:28992')

land_use <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=GRONDGEBRUIK_2017&THEMA=grondgebruik")

student_housing <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=JONGERENSTUDENTENHUISVESTING&THEMA=jongerenstudentenhuisvesting")

overnight <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=OVERNACHTINGSBELEID&THEMA=overnachtingsbeleid")

parks <- st_read("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=PARKPLANTSOENGROEN&THEMA=stadsparken")

metro_lines <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=TRAMMETRO_LIJNEN_2020&THEMA=trammetro")

metro_stops <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=TRAMMETRO_PUNTEN_2020&THEMA=trammetro")

hist_build <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=HISTORISCHE_BEBOUWING&THEMA=archeologie")

wall_art <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=WANDKUNST&THEMA=wandkunst")

barbecue <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=BBQ&THEMA=bbq")

markets <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=MARKTEN&THEMA=markten")

playgrounds <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=SPORT_OPENBAAR&THEMA=sport")

swim <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=ZWEMWATER&THEMA=zwemwater")

monuments <- read_sf("https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=MONUMENTEN&THEMA=monumenten")
monuments <- monuments[monuments$Soort %in% c("Beeldhouwkunst", "Bouwwerk", "Bouwblok", "Park Terrein"), ] # removing historic homes from the dataset
```

``` {r, message=FALSE, warning=FALSE, results=FALSE}
#Setting the bounding box to pull in OSM data
xmin = st_bbox(districts)[[1]]
ymin = st_bbox(districts)[[2]]
xmax = st_bbox(districts)[[3]]  
ymax = st_bbox(districts)[[4]]

# Bars
bar <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'amenity', value = c("bar", "biergarten", "pub")) %>%
  osmdata_sf()
bar <-
  bar$osm_points %>%
  .[districts,]

# Restaurants
restaurant <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'amenity', value = c("restaurant", "cafe")) %>%
  osmdata_sf()
restaurant <-
  restaurant$osm_points %>%
  .[districts,]

university <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'amenity', value = c("university", "college")) %>%
  osmdata_sf()
university <-
  university$osm_points %>%
  .[districts,]

## Schools
schools <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'amenity', value = c("school")) %>%
  osmdata_sf()
schools <-
  schools$osm_points %>%
  .[districts,]

## land use - retail
retail <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'landuse', value = c("retail")) %>%
  osmdata_sf()
retail <-
  retail$osm_points %>%
  .[districts,]

## stadiums/sports centers
stadiums <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'leisure', value = c("stadium")) %>%
  osmdata_sf()
stadiums <-
  stadiums$osm_points %>%
  .[districts,]

## Parks
parks_osm <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'leisure', value = c("park")) %>%
  osmdata_sf()
parks_osm <-
  parks_osm$osm_points %>%
  .[districts,]

## industrial buildings
industrial <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>%
  add_osm_feature(key = 'building', value = c("industrial")) %>%
  osmdata_sf()
industrial <-
  industrial$osm_points %>%
  .[districts,]
```

# Exploratory Analysis 
Before engineering any additional features for our model, we reviewed data available from the Airbnb dataset. Figure 1 below maps the locations and prices of Amsterdam Airbnbs in 2018. With regard to the spatial process of rental price and number of Airbnbs, there's a higher concentration of Airbnb rentals in the more central part of the city, with fewer units extending outward. Higher prices are also more concentrated in the city center. 

Figures 2 and 3 show some of the categorical and numerical features included in the Airbnb dataset and their relationship to price. We can see that, on average, price is higher when units have real beds and offer the entire home to the renter as opposed to a single bedroom. Some neighborhoods, including Buiksloterham located on the northern part of the canal, have higher prices on average and property types like serviced apartments and villas also attract higher priced rentals. The numerical features indicate a positive relationship between price and the number of beds, baths, the number of people the home can accommodate, and how often the home is available during the year.
``` {r, warning=FALSE, fig.align='center'}
#######################
# Neighborhood Plot
######################
listings_details.sf  <- listings_details %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(neighborhoods_new.sf))

listings_details.sf$price2 = as.numeric(gsub("\\$", "", listings_details.sf$price))

ggplot() +
  geom_sf(data = neighborhoods_new.sf, fill = "#2f4550") + 
  geom_sf(data = listings_details.sf, aes(colour = q5(price2)), 
          show.legend = "point", size = .1) +
  scale_colour_manual(values = paletteorngs,
                      labels = qBr(listings_details.sf, "price2"),
                      name = "Nightly Airbnb Price\n(Quintile Breaks)") +
  labs(title="Nightly Airbnb Price, Amsterdam",
       subtitle = "Figure 1") +
  mapTheme()
```

```{r echo=TRUE, fig.height=20, fig.width=15, message=FALSE, warning=FALSE}
#taking out outlier property types
listings_details = filter(listings_details, 
                               property_type != "Lighthouse" & 
                               property_type != "Earth House" & 
                               property_type != "Nature lodge" & 
                               property_type != "Castle" &
                               property_type != "Tent" &
                               property_type != "Campsite")

listings_details %>% 
  dplyr::select(price2, property_type, room_type, neighbourhood, bed_type) %>%
  gather(Variable, Value, -price2) %>% 
   ggplot(aes(Value, price2)) +
     geom_bar(position = "dodge", stat = "summary", fun.y = "mean", fill ="#7fc3dc", col="#1a81a2", alpha = 0.9 ) +
     facet_wrap(~Variable, ncol = 1, scales = "free") +
  labs(title = "Price as a function of categorical variables", y = "Mean Price", subtitle = "Figure 2") +
     plotTheme() + theme(axis.text.x = element_text(angle = 45, size=20, hjust = 1),
                         axis.text.y = element_text(size = 20),
                         plot.title = element_text(size = 30),
                         plot.subtitle = element_text(size = 20),
                         axis.title.x = element_text(size = 20),
                         axis.title.y = element_text(size = 20))
```

```{r, message=FALSE, warning=FALSE, fig.height=5, fig.width=10}
st_drop_geometry(listings_details.sf) %>% 
  dplyr::select(price2, accommodates, bedrooms, review_scores_location, availability_365) %>%
  filter(price2 <= 1000000) %>%
  gather(Variable, Value, -price2) %>% 
  ggplot(aes(Value, price2)) +
  geom_point(shape = 16, size = 3,color= "#cde1b1", alpha = 0.5) + geom_smooth(method = "lm", se=F, colour = "#E86E23") +
  facet_wrap(~Variable, ncol = 4, scales = "free") +
  labs(title = "Price as a function of numerical variables", subtitle = "Figure 3") +
  plotTheme() + theme(plot.title = element_text(size = 30),
                      plot.subtitle = element_text(size = 20),
                      axis.title.x = element_text(size = 20),
                      axis.title.y = element_text(size = 20))
```


# Feature Engineering
Apart from some of the features in the original Airbnb dataset, we engineered a series of variables for our final model with the goal of minimizing error in rental price. We wanted to ensure our model was both accurate and generalizable in predicting a range of property types and locations. 

We engineered variables based on descriptions that Airbnb hosts have posted about their home and analyzed them extract keywords associated with higher or lower price properties. We leveraged the nearest neighbor method to look at access to various services and amenities in the city like swimming areas and markets. We calculated *lagPrice* for each listing, which is the average price of the three closest homes to each Airbnb, and incorporated *local Moran's I* analysis, examining high-priced hotspots throughout Amsterdam and calculating the distance to the closest highly significant cluser of high priced homes hotspots. Finally, we also separated select contiuous variables into categories and transformed one categorical variable to numerical to better account for skews in the distribution and enhance the model's accuracy.

### *Description Analysis*
We first analyzed the descriptions associated with each listing to determine key words associated with higher or lower prices. We in turn created dummy variables associated with different price points.
```{r echo=TRUE, message=FALSE, warning=FALSE}
listings_details.sf$luxury <- ifelse(grepl("luxur",  ignore.case=TRUE, listings_details.sf$name), "yes", "no") 

listings_details.sf$canal <- ifelse(grepl("canal", ignore.case=TRUE, listings_details.sf$name), "yes", "no") 

listings_details.sf$expamen <- ifelse(grepl("view|terrace|spac|rooftop|loft|roof", ignore.case=TRUE, listings_details.sf$name), "yes", "no") 

listings_details.sf$expcodes <- ifelse(grepl("family|big|light|heart|large|design|pijp|jordaan", ignore.case=TRUE, listings_details.sf$name), "yes", "no") 

listings_details.sf$citycenterdesc <- ifelse(grepl("center|centre",ignore.case=TRUE, listings_details.sf$name), "yes", "no") 

listings_details.sf$cheapcodes <- ifelse(grepl("cozy|cosy|free|room|little|bed|garden|vondelpark", ignore.case=TRUE, listings_details.sf$name), "yes", "no") 

listings_details.sf$pool <- ifelse(grepl("Pool", ignore.case=TRUE, listings_details.sf$amenities), "yes", "no")

listings_details.sf$expamencat <- ifelse(grepl("friendly|detector|workspace|hot|water|parking|private|first|aid|greets|luggage|wide|kit|linens|dropoff|balcony|step-free|books|Wide|dryer|laptop|access|premises", ignore.case=TRUE, listings_details.sf$amenities), "yes", "no")


listings_details.sf$expsummary <- ifelse(grepl("located|minutes|walk|bars|view|center|away|museum|tram", ignore.case=TRUE, listings_details.sf$summary), "yes", "no")


listings_details.sf$expdescrip <- ifelse(grepl("kitchen|located|floor|garden|walk|large|double|open|centre|beautiful|center|terrace|fully|canal|big|shops|two|close|view|also|famous|bright|", ignore.case=TRUE, listings_details.sf$description), "yes", "no")


listings_details.sf$expneighbdesc <- ifelse(grepl("walk|city| shops|bars|nice|just|museum|distance|close|min|Jordaan|best|local|Anne|popular|trendy|Gogh|Pijp|quiet|meters|right|one|park|Amstel|Cuyp", ignore.case=TRUE, listings_details.sf$summary), "yes", "no")

listings_details.sf$expneighwoclou<- ifelse(grepl("Pijp|Plantage|Westelijke|Zeeburg|Zeeheldenbuurt|Lastage|Weesperbuurt|Oud-Zuid|", ignore.case=TRUE, listings_details.sf$summary), "yes", "no")
```

### *Access to amenities and services*
For a series of variables from OSM and Amsterdam's open data portal, we calculated the nearest neighbor distance from each listing to the below (dis)amenities and services around the city.
```{r echo=TRUE, message=FALSE, warning=FALSE}
st_c <- st_coordinates

## Metro Stops
metro_stops.sf <- metro_stops%>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
metro_stops.sf <- st_join(metro_stops.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    metrostops_nn2 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(metro_stops.sf)), 2))

## Swimming Areas
swim.sf <- swim%>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
swim.sf <- st_join(swim.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    swim_nn1 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(swim.sf)), 1))

## Wall Art
wall_art.sf <- wall_art%>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
metro_stops.sf <- st_join(wall_art.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    wallart_nn3 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(wall_art.sf)), 1))

## Markets
markets.sf <- markets%>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
markets.sf <- st_join(markets.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    markets_nn1 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(markets.sf)), 1))

## Playgrounds
playgrounds.sf <- playgrounds %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
playgrounds.sf <- st_join(playgrounds.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    playgrounds_nn2 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(playgrounds.sf)), 2))

## Student Housing
students.sf <- student_housing %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
students.sf <- st_join(students.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    students_nn2 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(students.sf)), 2))

## Historic buildings
hist_build.sf <- hist_build %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
hist_build.sf <- st_join(hist_build.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    histbuild_nn3 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(hist_build.sf)), 3))

## Monumuments
monuments.sf <- monuments %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
monuments.sf <- st_join(monuments.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    monuments_nn3 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(monuments.sf)), 3))

## Bars
bar.sf <- bar %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
bar.sf <- st_join(bar.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    bar_nn2 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(bar.sf)), 2))

## Restaurants
restaurant.sf <- restaurant %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
restaurant.sf <- st_join(restaurant.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    restaurant_nn3 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(restaurant.sf)), 3))

## University
university.sf <- university %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
university.sf <- st_join(university.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    university_nn1 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(university.sf)), 1))

## Schools
schools.sf <- schools %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
schools.sf <- st_join(schools.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    schools_nn2 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(schools.sf)), 2))

## Retail
retail.sf <- retail %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
retail.sf <- st_join(retail.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    retail_nn3 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(retail.sf)), 3))

## Industrial
industrial.sf <- industrial %>%
  st_transform(st_crs(districts.sf)) %>%
  st_as_sf()
industrial.sf <- st_join(industrial.sf, districts.sf, join = st_intersects, left = FALSE)

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    industrial_nn1 = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(industrial.sf)), 1))
```

### *Lagprice: Average price of three closest rentals*
We eliminated outlier property types and calculated the average price of the three closest rental properties for each listing.
``` {r k near price lag}
listings_details.sf <- subset(listings_details.sf, price2 > 0)

listings_details.sf = filter(listings_details.sf, 
                               property_type != "Lighthouse" & 
                               property_type != "Earth house" & 
                               property_type != "Nature lodge" & 
                               property_type != "Castle" &
                               property_type != "Tent" &
                               property_type != "Campsite" &
                               property_type != "Barn")


k_nearest_neighbors = 3

#prices
coords <- st_coordinates(listings_details.sf) 

# k nearest neighbors
neighborList <- knn2nb(knearneigh(coords, k_nearest_neighbors))
spatialWeights <- nb2listw(neighborList, style="W")
listings_details.sf$lagPrice <- lag.listw(spatialWeights, listings_details.sf$price2)
```

### *Local Moran's I*
Figure 4 shows more localized clustering of higher priced homes along to the canal as well as just north of the canal. Figure 5 identifies the significant hotspots of high-priced rentals, which we then transformed into polygons and calculated distance from each rental property to its closest significant fishnet cell.
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center'}
# Create fishnet
fishnet <- 
  st_make_grid(neighborhoods_new.sf, cellsize = 200) %>%
  st_sf() %>%
  mutate(uniqueID = rownames(.))

# Create fishnet with the average price of the rental properties located in each grid cell
price_net <- 
  dplyr::select(listings_details.sf) %>% 
  mutate(price = listings_details.sf$price2) %>% 
  aggregate(., fishnet, mean) %>%
  mutate(price = replace_na(price, 0),
         uniqueID = rownames(.),
         cvID = sample(round(nrow(fishnet) / 24), size=nrow(fishnet), replace = TRUE))

price_net <- subset(price_net, price > 0)

ggplot() +
  geom_sf(data=fishnet, fill = "grey40") +
  geom_sf(data = price_net, aes(fill = price)) +
  scale_fill_viridis() +
  labs(title = "Average Rental Price", subtitle = "Figure 4") +
  mapTheme()
```
```{r echo=TRUE, fig.height=10, fig.width=10, message=FALSE, warning=FALSE}
# Local Moran's I
## Create neighbor list and spatial weights matrix
final_net.nb <- poly2nb(as_Spatial(price_net), queen=TRUE)
final_net.weights <- nb2listw(final_net.nb, style="W", zero.policy=TRUE)

# Combining the price_net with localmoran test
final_net.localMorans <- 
  cbind(
    as.data.frame(localmoran(price_net$price, final_net.weights)),
    as.data.frame(price_net)) %>% 
    st_sf() %>%
      dplyr::select(Avg_Price = price, 
                    Local_Morans_I = Ii, 
                    P_Value = `Pr(z > 0)`) %>%
      mutate(Significant_Hotspots = ifelse(P_Value <= 0.001, 1, 0)) %>%
      gather(Variable, Value, -geometry)
  
vars <- unique(final_net.localMorans$Variable)
varList <- list()

for(i in vars){
  varList[[i]] <- 
    ggplot() +
      geom_sf(data = fishnet, fill = "grey40") +
      geom_sf(data = filter(final_net.localMorans, Variable == i), 
              aes(fill = Value), colour=NA) +
      scale_fill_viridis(name="") +
      labs(title=i, subtitle = "Figure 5") +
      mapTheme() + theme(legend.position="bottom")}

do.call(grid.arrange,c(varList, ncol = 4, top = "Local Morans I statistics, Price"))
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
sig_net <- 
  dplyr::filter(final_net.localMorans, final_net.localMorans $ Variable == "Significant_Hotspots") 

sig_net <-
  dplyr::filter(sig_net, sig_net $ Value == 1)

sig_net.sf <- sig_net %>%
  st_as_sf(coords = "geometry", crs = 4326, agr = "constant") %>%
  st_transform('EPSG:28992')

listings_details.sf <-
  listings_details.sf %>%
  mutate(
    sig_cell = nn_function(st_c(st_centroid(listings_details.sf)), st_c(st_centroid(sig_net.sf)), 1))
```

### *Transforming Variables*
We manipulated three of our numerical variables and one categorical variables and transformed them to improve their predictive power in the model.
``` {r, warning=FALSE, error=FALSE, message=FALSE}
listings_details.sf <- 
  listings_details.sf %>% 
  mutate(size_of_group = 
          case_when(guests_included <= 4  ~ "Large Group",
                    guests_included <= 2 & (guests_included) > 4  ~ "Small Group",
                    guests_included >= 1 ~ "Solo"))

listings_details.sf <- 
  listings_details.sf %>% 
  mutate(expneighbors = 
          case_when(lagPrice <= 90  ~ "Cheap Neighbors",
                   lagPrice <= 250 & (lagPrice) > 90  ~ "Average Neighbors",
                    lagPrice >= 251 ~ "Expensive Neighbors"))

listings_details.sf <- 
  listings_details.sf %>% 
  mutate(hotspotlevel = 
          case_when(sig_cell <= 368  ~ "Not Hot Spot",
                   sig_cell <= 1500 & (sig_cell) > 369  ~ "Semi-Hot",
                    sig_cell >= 1501 ~ "Hot Spot"))

entirehomelist <- list("Entire home/apt"
                        )
listings_details.sf <- listings_details.sf %>%
  mutate(Entire_Home = room_type %in% entirehomelist)
listings_details.sf$Entire_Home <- ifelse(listings_details.sf$Entire_Home == "TRUE", 1, 0)
```

# Notable Variables
The correlation matrix below in Figure 6 shows the included numerical variables in our final model. These included a combination of the variables in the Airbnb dataset as well as the engineered features. Figure 7 looks at three of the significant engineered features, including average distance to the three nearest historical buildings, average price of three nearest rentals, and the existance of coded language affiliated with cheaper properties.
```{r echo=TRUE, fig.height=30, fig.width=30, message=FALSE, warning=FALSE}
Vars <- listings_details.sf %>%
  dplyr::select(price2,
                accommodates, bathrooms, bedrooms, availability_365, number_of_reviews, review_scores_rating, markets_nn1, metrostops_nn2, playgrounds_nn2, histbuild_nn3, monuments_nn3, restaurant_nn3, university_nn1, retail_nn3, industrial_nn1, lagPrice, sig_cell, minimum_nights, students_nn2, wallart_nn3, schools_nn2, retail_nn3, industrial_nn1, lagPrice, sig_cell, beds, review_scores_accuracy, review_scores_cleanliness, review_scores_rating, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month, guests_included) %>%
  na.omit()


Vars <- st_drop_geometry(Vars)

ggcorrplot(
  round(cor(Vars), 1), 
  p.mat = cor_pmat(Vars),
  colors = c("#037499","light grey","#f6b492"), 
  type="lower",
  insig = "blank") +  
  labs(title = "Correlation across numeric variables", subtitle = "Figure 6") +
  plotTheme() + theme(axis.text.x = element_text(angle = 45, size=25, hjust = 1),
                         axis.text.y = element_text(size = 25),
                         plot.title = element_text(size = 30),
                         plot.subtitle = element_text(size = 20))
```

```{r, warning=FALSE, error=FALSE, message=FALSE, fig.height=8, fig.width=15}
Hist_build_plot <- st_drop_geometry(listings_details.sf) %>% 
  dplyr::select(price2, histbuild_nn3) %>%
  filter(price2 <= 1000000) %>%
  gather(Variable, Value, -price2) %>% 
  ggplot(aes(Value, price2)) +
  geom_point(shape = 16, size = 1, color= "#72b7cd", alpha = 0.7) + geom_smooth(method = "lm", se=F, colour = "#E86E23") +
  facet_wrap(~Variable, ncol = 3, scales = "free") +
  plotTheme()
             
lagPrice_plot <- st_drop_geometry(listings_details.sf) %>% 
  dplyr::select(price2, lagPrice) %>%
  filter(price2 <= 1000000) %>%
  gather(Variable, Value, -price2) %>% 
  ggplot(aes(Value, price2)) +
  geom_point(shape = 16, size = 1,color= "#cde1b1", alpha = 0.5) + geom_smooth(method = "lm", se=F, colour = "#E86E23") +
  facet_wrap(~Variable, ncol = 4, scales = "free") +
  plotTheme()

cheapcodes_plot <- st_drop_geometry(listings_details.sf) %>% 
  dplyr::select(price2, cheapcodes) %>%
  filter(price2 <= 1000000) %>%
  gather(Variable, Value, -price2) %>% 
  ggplot(aes(Value, price2)) +
  geom_point(shape = 16, size = 1,color= "#f6c192", alpha = 0.5) + geom_smooth(method = "lm", se=F, colour = "#E86E23") +
  facet_wrap(~Variable, ncol = 3, scales = "free") +
  plotTheme()

grid.arrange(Hist_build_plot, lagPrice_plot, cheapcodes_plot, ncol=3, top = "Price as a function of average distance to three nearest historical buildings, average price of three nearest rentals, and the existence of coded language affiliated with cheaper properties", bottom = "Figure 7")
```

# The Checkbnb Model
After engineering the features, our final model and list of variables can be seen below. We used a combination of categorical and numerical variables to build and hone our model in order to minimize error and ensure it generalizes to a wide set of rental property types and locations within the city. The R-squared value of 0.5 indicates that the model accounts for approximately 50% of variation in home price.
```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
listings_details.sf <- subset(listings_details.sf, price2 > 0)

reg1 <- lm(price2 ~ ., data = st_drop_geometry(listings_details.sf) %>% 
                                 dplyr::select(price2, property_type, accommodates, bathrooms, bedrooms, neighbourhood, room_type, availability_365, number_of_reviews, minimum_nights, Entire_Home, markets_nn1, metrostops_nn2, students_nn2, wallart_nn3, playgrounds_nn2, histbuild_nn3, monuments_nn3, restaurant_nn3, university_nn1, schools_nn2, retail_nn3, industrial_nn1, luxury, lagPrice, canal, expamen, expcodes, citycenterdesc, cheapcodes, pool, sig_cell, beds, review_scores_accuracy, review_scores_cleanliness, review_scores_rating, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month, expamencat, expsummary, expdescrip, expneighbdesc, expneighwoclou, guests_included, cancellation_policy, size_of_group, expneighbors,hotspotlevel))

reg1.summary <- coef(summary(reg1))
kable(reg1.summary,format = "html", caption = "Regression Results Summary") %>% 
  kable_styling()

#create output table of regression summary

first_column <- c("R2", "Adjusted R2")
second_column <- c("0.5063","0.5026")

regression_stats <- data.frame(first_column, second_column)

kable(regression_stats,format = "html", col.names = c('', '')) %>% 
  kable_styling() %>%
  footnote(general_title = "\n")
```

# Training and Testing our Model
We trained and tested our model on the selected variables to ensure both accuracy and generalizability. We divided our rental property data and features into separate training and test sets. We used the training set to test the generalizability of the model by accurately predicting home sale prices on a different set of data.

The summary output of the model provides both the significance values for each of the utilized variables to test prices as well as statistics that inform how accurate the model is in predicting price. The p-value, provided for each variable, indicates the confidence level that the variable is a good predictor of home price.
```{r echo=FALSE, message=FALSE, warning=FALSE}


rents <- subset(listings_details.sf, price2 > 0)

rents <- rents[,colSums(is.na(rents))<nrow(rents)]




rents <- dplyr::select (rents, price2, property_type, accommodates, bathrooms, bedrooms, neighbourhood, room_type, availability_365, number_of_reviews, minimum_nights, Entire_Home, markets_nn1, metrostops_nn2, students_nn2, wallart_nn3, playgrounds_nn2, histbuild_nn3, monuments_nn3, restaurant_nn3, university_nn1, schools_nn2, retail_nn3, industrial_nn1, luxury, lagPrice, canal, expamen, expcodes, citycenterdesc, cheapcodes, pool, sig_cell, beds, review_scores_accuracy, review_scores_cleanliness, review_scores_rating, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month, expamencat, expsummary, expdescrip, expneighbdesc, expneighwoclou, guests_included, cancellation_policy, size_of_group, expneighbors,hotspotlevel)

rents<- na.omit(rents)

# Setting up test and training datasets
set.seed(31357)

inTrain <- caret::createDataPartition( 
  y = rents$price2, 
  p = .70, list = FALSE)

rents.training <- rents[inTrain,] 
rents.test <- rents[-inTrain,]  

#Multivariate regression
reg.training <- lm(price2 ~ ., data = st_drop_geometry(rents.training) %>% 
             dplyr::select(price2, property_type, accommodates, bathrooms, bedrooms, neighbourhood, room_type, availability_365, number_of_reviews, minimum_nights, Entire_Home, markets_nn1, metrostops_nn2, students_nn2, wallart_nn3, playgrounds_nn2, histbuild_nn3, monuments_nn3, restaurant_nn3, university_nn1, schools_nn2, retail_nn3, industrial_nn1, luxury, lagPrice, canal, expamen, expcodes, citycenterdesc, cheapcodes, pool, sig_cell, beds, review_scores_accuracy, review_scores_cleanliness, review_scores_rating, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month, expamencat, expsummary, expdescrip, expneighbdesc, expneighwoclou, guests_included, cancellation_policy, size_of_group, expneighbors,hotspotlevel))

reg.training.summary <- coef(summary(reg.training))
kable(reg.training.summary,format = "html", caption = "Regression Results Summary") %>% 
  kable_styling()

#create output table of regression summary

first_column <- c("R2", "Adjusted R2")
second_column <- c("0.516","0.5109")

regression_stats <- data.frame(first_column, second_column)

kable(regression_stats,format = "html", col.names = c('', '')) %>% 
  kable_styling() %>%
  footnote(general_title = "\n")
```

# Cross Validation
This section looks at both model accuracy and generalizability. As this analysis will indicate, our predictions are useful in showing how well our model does in accurately predicting rental price in our test set. Our 100-fold cross validation specifically addresses how accurately our model predicts on new data and generalizes across holdout test sets. In turn, understanding our model's accuracy and generalizability is critical to ensuring that Checkbnb users get an accurate predicted rental price no matter their home specifications or location.

### *Model Accuracy*
In the process of honinig and engineering new variables for our model, we continually improved it so as to, in part, increase accuracy. As shown in the table below, we calculated how well our final model predicts on the testing set, which indicates a mean absolute error (MAE) of **$38**. This indicates that on average, we are either under or over predicting rental prices by **$38**. The mean absolute percent error (MAPE) of our model is approximately 26%. 
```{r echo=FALSE, message=FALSE, warning=FALSE}
rents.test <-
  rents.test %>%
  mutate(Regression = "Baseline Regression",
         price2.Predict = predict(reg.training, rents.test),
         price2.Error = price2.Predict - price2,
         price2.AbsError = abs(price2.Predict - price2),
         price2.APE = (abs(price2.Predict - price2)) / price2.Predict)

ErrorTable <- 
  rents.test %>% 
  dplyr::summarize(Regression = "Baseline Regression",
                   MAE = mean(price2.AbsError, na.rm = T), 
                   MAPE = mean(price2.AbsError, na.rm = T) / mean(price2, na.rm = T)) 

ErrorTable %>% 
  st_drop_geometry %>%
  group_by(Regression) %>%
  arrange(desc(MAE)) %>% 
  kable(caption = "MAE and MAPE for Test Set Data") %>% kable_styling("striped", full_width = F) %>%
  row_spec(1, color = "black", background = "#ceeece")
```

The plots below show how well our model is predicting rental prices in both our training and test set data. The orange line indicates a perfect fit, meaning that our predicted rent prices match those of the actual values. As seen in the bottom right scatterplot, we are almost perfectly predicting rental prices in accordance with their actual values in our training data. However, our model does slightly underpredict on higher priced rentals in our testing data set.Figure 9, examines the underprediction occurring more closely, where the data is split into 10 deciles or sections. You can see more clearly that we are slightly overpredicting lower prices properties in the initial deciles, perfectly matching properties around the 8th decile, and underpredicting the higher priced homes towards the final deciles.

```{r fig.height=20, fig.width=20, message=FALSE, warning=FALSE, error=FALSE, echo=FALSE}
reg.training_predict <- predict(reg.training, newdata = rents.test)

rmse.train <- caret::MAE(predict(reg.training), rents.training$price2)
rmse.test <- caret::MAE(reg.training_predict, rents.test$price2)

preds.train <- data.frame(pred   = predict(reg.training),
                          actual = rents.training$price2,
                          source = "training data")
preds.test  <- data.frame(pred   = reg.training_predict,
                          actual = rents.test$price2,
                          source = "testing data")

preds <- rbind(preds.train, preds.test)

ggplot(preds, aes(x = pred, y = actual, color = source)) +
  geom_point() +
  geom_smooth(method = "lm", color = "green") +
  geom_abline(color = "orange") +
  coord_equal() +
  theme_bw() +
  facet_wrap(~source, ncol = 2) +
  labs(title = "Comparing predictions to actual values",
       x = "Predicted Value",
       y = "Actual Value",
       subtitle = "Figure 8") +
  theme(plot.title = element_text(size = 30),
        plot.subtitle = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.text.x = element_text(size = 20),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        legend.position = "none"
  )
```

``` {r, message=FALSE, warning=FALSE, error=FALSE}
preds %>%
    mutate(price_Decile = ntile(actual, 10)) %>%
  group_by( price_Decile) %>%
    summarize(meanObserved = mean(actual, na.rm=T),
              meanPrediction = mean(pred, na.rm=T)) %>%
    gather(Variable, Value, -price_Decile) %>%          
    ggplot(aes(price_Decile, Value, shape = Variable)) +
      geom_point(size = 3, color = "black") + geom_path(aes(group = price_Decile), colour = "black") +
      scale_shape_manual(values = c(2, 17)) +
      labs(title = "Predicted and observed Price by observed Price Decile", subtitle = "Figure 9")
```

### *Model Generalizability*
We then looked to test the generalizability of our model using a 100-fold cross-validation test. In this analysis, we split our data into 100 groups - one group acts as the test set with the remaining 99 groups acting as the training set. This process is repeated for each individual group, resulting in 100 "scores" telling us how well our model predicted for each sample of new data. 

Our average MAE of **$38** is similar to the MAE of our initial test, and our standard deviation of **$3.91** suggests there is no significant variation across our 100 groups. The histogram in Figure 9 below confirms the minimal variation showing a relatively narrow distribution of errors. This indicates that our model is relatively generalizable to new rental price data.
```{r, message=FALSE, warning=FALSE, error=FALSE}
fitControl <- trainControl(method = "cv", 
                           number = 100,
                           savePredictions = TRUE)

set.seed(717)

reg1.cv <- 
  train(price2 ~ ., data = st_drop_geometry(rents) %>% 
          dplyr::select(price2, property_type, accommodates, bathrooms, bedrooms, neighbourhood, room_type, availability_365, number_of_reviews, minimum_nights, Entire_Home, markets_nn1, metrostops_nn2, students_nn2, wallart_nn3, playgrounds_nn2, histbuild_nn3, monuments_nn3, restaurant_nn3, university_nn1, schools_nn2, retail_nn3, industrial_nn1, luxury, lagPrice, canal, expamen, expcodes, citycenterdesc, cheapcodes, pool, sig_cell, beds, review_scores_accuracy, review_scores_cleanliness, review_scores_rating, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month, expamencat, expsummary, expdescrip, expneighbdesc, expneighwoclou, guests_included, cancellation_policy, size_of_group, expneighbors,hotspotlevel), 
        method = "lm", 
        trControl = fitControl, 
        na.action = na.pass)

#Standard Deviation and Histogram of MAE
reg1.cv.resample <- reg1.cv$resample

ggplot(reg1.cv.resample, aes(x=MAE)) + geom_histogram(color = "#ff5a5f", fill = "#f6c192", alpha = .7, bins = 50) + 
  labs(title="Histogram of Mean Average Error Across 100 Folds",
       subtitle = "Figure 10") +
  plotTheme()
```

```{r message=FALSE, warning=FALSE, error=FALSE}
cv_preds <- reg1.cv$pred

map_preds <- rents %>% 
  rowid_to_column(var = "rowIndex") %>% 
  left_join(cv_preds, by = "rowIndex") %>% 
  mutate(rentPrice.AbsError = abs(pred - obs),
         PercentError = (rentPrice.AbsError / price2)*100) 

map_preds_new2 <- st_join(neighborhoods_new.sf, map_preds, left = TRUE)

map_preds_sum <- map_preds_new2 %>% 
  group_by(neighbourhood.x) %>% 
  summarise(meanMAE = mean(rentPrice.AbsError),
            meanMAPE = mean(PercentError))

map_preds_sum %>%
  group_by(neighbourhood.x) %>%
    st_sf() %>%
    ggplot() + 
      geom_sf(data = map_preds_sum, fill = "grey40") +
      geom_sf(aes(fill = meanMAPE)) +
      scale_fill_gradient(low = paletteblues[1], high = paletteblues[5],
                        name = "meanMAPE") +
    labs(title = "Mean MAPE by neighborhood",
         subtitle = "Figure 11") +
    mapTheme()

```

# Conclusion
To optimize the user experience for the Checkbnb customer, we successfully honed a relatively accurate and generalizable model that minimizes price error. Our goal at Checkbnb is for each user to get an accurate predicted price for their individual home so that they can appropriately list and rent their units in a timely fashion. We were able to use and engineer a diverse set of variables that accounts for the spatial process at the neighborhood scale and overall variation in price. Under a stringent and complicated regulatory landscape, this model provides a tool that helps users effectively navigate the Airbnb rental market that is otherwise less accessible in Amsterdam. Airbnb wants to make the prospect of becoming a host as simple and streamlined as possible, and we believe our model effectively achieves this goal.

To improve the analysis, more up-to-date Airbnb data is required since we don't know how the regulatory changes that the City has undertaken may have impacted the rental market. For example, since the city banned Airbnbs from three city center neighborhoods, there may be implications on increased rental prices as a result of a strained market. There is also opportunity to further utilize neighborhood demographics, socioeconomic indicators, and other census variables that we were unable to acquire for this particular study. Access to this data would allow us to better generalize across different neighborhood contexts given and pinpoint any spatial biases in our model. In addition,further streamlining of Amsterdam's neighborhood nomenclature and curtailing the percentage errors in the more Western neighborhoods of Amsterdam will further improve this model 

View our Checkbnb pitch here: https://youtu.be/pA7AGRt8cWs 